# Iterative Matrix Builder - Architecture\n\n## System Integration\n\n```\nAPI Request Flow\n================\n\ncontroller(origin, waypoints, criterion, avoid_zones)\n    │\n    ├─ Coords = [origin] + waypoints\n    │\n    ├─ len(coords) <= 100 AND no avoid_zones?\n    │   ├─ YES → Try get_osrm_matrix(coords)  [Direct Public API]\n    │   │         ├─ Success? Return matrices ✓\n    │   │         └─ Failure? Continue...\n    │   └─ NO → Continue...\n    │\n    ├─ Try get_osrm_matrix_from_local_container(coords)  [Local OSRM]\n    │   ├─ Success? Return matrices ✓\n    │   └─ Failure? Continue...\n    │\n    ├─ Try get_osrm_matrix_iterative(coords)  [NEW - Iterative Builder]\n    │   ├─ Success? Return matrices ✓\n    │   └─ Failure? Continue...\n    │\n    └─ Fallback get_geodesic_matrix(coords)  [Pure Geodesic]\n        └─ Return matrices (slower but always works)\n```\n\n## Batch Creation Strategy\n\n```\nFor N = 250 coordinates with batch_size = 95:\n\nPhase 1: Origin (point 0) → Waypoint batches\n==============================================\nBatch 1:  0 → [1, 2, ..., 95]         (96 coords)\nBatch 2:  0 → [96, 97, ..., 190]      (96 coords)\nBatch 3:  0 → [191, 192, ..., 249]    (60 coords)\n\nPhase 2: Each waypoint → Remaining waypoints\n=============================================\nBatch 4:  1 → [2, 3, ..., 96]         (96 coords)\nBatch 5:  1 → [97, 98, ..., 191]      (96 coords)\nBatch 6:  1 → [192, 193, ..., 249]    (59 coords)\n... (continues for waypoints 2-249)\n\nTotal batches: ~421 for 250 coordinates\nAPI requests: ~421 (1 request per batch)\nMatrix pairs covered: 250 × 249 / 2 ≈ 31,000 unique pairs\n```\n\n## Batch Processing Pipeline\n\n```\nFor Each Batch:\n\n1. Create Request\n   ├─ Format batch coordinates as OSRM URL parameter\n   ├─ lng,lat;lng,lat;... format\n   └─ Up to 96 coordinates per request\n\n2. Try API Request (with retries)\n   ├─ Make HTTP GET to public OSRM API\n   ├─ Timeout: 10 seconds\n   │\n   ├─ Attempt 1 (base delay = 1.0s)\n   │   ├─ Success? → Proceed to Merge\n   │   ├─ Timeout? → Wait 1.0s, retry\n   │   └─ Error? → Wait 1.0s, retry\n   │\n   ├─ Attempt 2 (delay = 2.0s)\n   │   ├─ Success? → Proceed to Merge\n   │   ├─ Timeout? → Wait 2.0s, retry\n   │   └─ Error? → Wait 2.0s, retry\n   │\n   ├─ Attempt 3 (delay = 4.0s)\n   │   ├─ Success? → Proceed to Merge\n   │   └─ Failure? → Mark batch FAILED\n   │\n   └─ All attempts failed?\n       └─ Track failed pairs for geodesic fallback\n\n3. Merge Response (if successful)\n   ├─ Extract distances matrix from response\n   ├─ Extract durations matrix from response\n   │\n   ├─ For origin → waypoints:\n   │   └─ distances[origin][waypoint] = response[0][i+1]\n   │\n   └─ For waypoint → waypoint pairs:\n       └─ distances[w1][w2] = response[i+1][j+1]\n\n4. Rate Limiting\n   └─ If not last batch: sleep(0.5s)\n\n5. Progress\n   └─ Log: \"Batch X/Y processed\"\n```\n\n## Matrix Structure\n\n```\nComplete NxN Distance Matrix\n============================\n\nExample: 5 coordinates\n\n       0      1      2      3      4\n   ┌────────────────────────────────┐\n0  │   0   1000   2000   3000   4000 │\n1  │ 1000    0    1000   2000   3000 │\n2  │ 2000  1000    0    1000   2000 │\n3  │ 3000  2000   1000    0    1000 │\n4  │ 4000  3000   2000   1000    0  │\n   └────────────────────────────────┘\n\nProperties:\n• Diagonal = 0 (same point)\n• Symmetric (approximately)\n• All values >= 0\n• Units: meters (distance), seconds (duration)\n```\n\n## Error Handling Flow\n\n```\nAPI Call\n   │\n   ├─ Network Error (timeout, connection refused, etc.)\n   │   └─ Retry with exponential backoff\n   │       ├─ Attempt 1: wait 1s\n   │       ├─ Attempt 2: wait 2s\n   │       ├─ Attempt 3: wait 4s\n   │       └─ Failed? → Mark batch failed\n   │\n   ├─ HTTP Error (5xx, 4xx)\n   │   └─ Retry logic same as above\n   │\n   ├─ Invalid JSON Response\n   │   └─ Mark batch failed immediately (no retry)\n   │\n   ├─ Missing Fields (no 'distances' key)\n   │   └─ Mark batch failed immediately (no retry)\n   │\n   └─ Success: Valid response with distances + durations\n       └─ Merge into matrices\n\nAfter All Batches:\n   │\n   ├─ If any pairs failed\n   │   ├─ For each failed pair (i, j):\n   │   │   ├─ Calculate geodesic distance (geopy)\n   │   │   ├─ Assume 40 km/h speed\n   │   │   └─ Calculate duration = distance / speed\n   │   │\n   │   └─ Insert into matrices\n   │\n   └─ Return complete matrices\n```\n\n## Fallback Chain\n\n```\nFallback Strategy: Worst Case Recovery\n======================================\n\nAPI Batch Fails\n    │\n    ├─ Retry up to 3 times? YES → 3 attempts with backoff\n    │                       │\n    │                       └─ All failed?\n    │                           │\n    │                           └─ Mark pair failed\n    │\n    ├─ Collect all failed pairs\n    │   └─ (Could be 0 to N² pairs)\n    │\n    └─ For each failed pair:\n        ├─ Geodesic distance = great circle distance\n        ├─ Speed = 40 km/h (assumption)\n        ├─ Duration = distance / speed\n        └─ Insert into matrices\n\nResult: Complete valid matrix\n  • May have mix of API values + geodesic values\n  • Geodesic slightly longer than actual routing\n  • Still valid for TSP optimization\n```\n\n## Time Complexity Analysis\n\n```\nFor N coordinates:\n\nBatch Creation:        O(N²)\n  └─ Must cover all N×(N-1) pairs\n\nAPI Requests:          O(N²)\n  └─ One request per batch, ~N²/(2B) batches\n\nResponse Merging:      O(N²)\n  └─ Must merge all results\n\nGeodesic Fallback:     O(F) where F = failed pairs\n  └─ F ≤ N² worst case\n  └─ F typically << N² (most API calls succeed)\n\nTotal:                 O(N²)\n  └─ Dominated by number of coordinate pairs\n  └─ Not by algorithm complexity\n```\n\n## Rate Limiting Strategy\n\n```\nPublic OSRM API Limits:\n  • ~600 requests/hour (shared across all users)\n  • ~10 requests/second (burst capacity)\n\nDefault Settings:\n  • batch_size = 95 waypoints\n  • rate_limit_delay = 0.5 seconds\n\nConservative Approach:\n  • 2 requests/second = 1/5 of burst capacity\n  • 7,200 requests/hour available at 2 req/sec\n  • Ample safety margin\n\nCustomization:\n  • For unreliable API: increase rate_limit_delay\n  • For fast API: can decrease rate_limit_delay\n  • Monitor response times and adjust\n```\n\n## Performance Profile\n\n```\nScalability Analysis:\n\nCoordinates │ Batches │ API Calls │ Time (1s) │ Time (2s)\n──────────────────────────────────────────────────────────\n10          │    9    │     9     │   ~9s    │   ~18s\n50          │    ~300 │    ~300   │  ~5m     │   ~10m\n100         │  ~1,000 │  ~1,000   │  ~15m    │   ~30m\n200         │  ~4,000 │  ~4,000   │  ~1h     │   ~2h\n500         │ ~15,000 │ ~15,000   │  ~4h     │   ~8h\n\n* Times include 0.5s rate limit delay per request\n* Assumes 1s or 2s API latency per request\n* Actual times depend on API performance and network\n```\n\n## Class Diagram\n\n```\nIterativeMatrixBuilder\n═══════════════════════════════════════════════════════════\n\n+ __init__(coords, batch_size=95, max_retries=3, ...)\n├─ self.coords: List[Dict]           # Input coordinates\n├─ self.distances: List[List[float]]  # Output distance matrix\n├─ self.durations: List[List[float]]  # Output duration matrix\n└─ self.failed_pairs: List[Tuple[int, int]]  # Track failures\n\n+ build() → Tuple[matrices, matrices]\n│  └─ Main entry point: orchestrates entire process\n│\n├─ _create_batches() → List[RequestBatch]\n│  └─ Split coordinates into API request batches\n│\n├─ _process_batch(batch) → bool\n│  └─ Handle single batch with retry logic\n│\n├─ _request_batch(batch) → Dict\n│  └─ Make HTTP request to OSRM API\n│\n├─ _merge_batch_response(batch, response) → None\n│  └─ Extract data from response into matrices\n│\n├─ _mark_batch_failed(batch) → None\n│  └─ Track failed pairs for fallback\n│\n└─ _apply_geodesic_fallback() → None\n   └─ Calculate distances for failed pairs\n\n\nRequestBatch (Data Class)\n═════════════════════════════════════════════════════════════\n\n+ origin_idx: int\n+ waypoint_indices: List[int]\n+ coords: List[Dict]\n\n+ size: int (property)\n│  └─ Returns: 1 + len(waypoint_indices)\n│\n└─ to_coord_string() → str\n   └─ Format: \"lng,lat;lng,lat;...\"\n```\n