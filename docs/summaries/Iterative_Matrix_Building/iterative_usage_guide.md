# Iterative Matrix Builder - Quick Reference\n\n## Problem & Solution\n\n**Problem**: Public OSRM API limits requests to ~100 waypoints. When local container is unavailable and you have >100 coordinates, routing fails.\n\n**Solution**: `IterativeMatrixBuilder` automatically chunks requests and builds the complete matrix in batches.\n\n## Quick Start\n\n### Basic Usage\n\n```python\nfrom webrotas.iterative_matrix_builder import IterativeMatrixBuilder\n\n# Your coordinates\ncoords = [\n    {\"lat\": -23.55, \"lng\": -46.57},\n    {\"lat\": -23.54, \"lng\": -46.58},\n    # ... up to 1000+ coordinates\n]\n\n# Build matrix\nbuilder = IterativeMatrixBuilder(coords)\ndistances, durations = builder.build()\n\n# Use matrices for routing\nprint(f\"Distance from 0→1: {distances[0][1]} meters\")\nprint(f\"Duration from 0→1: {durations[0][1]} seconds\")\n```\n\n### With Custom Parameters\n\n```python\nbuilder = IterativeMatrixBuilder(\n    coords,\n    batch_size=80,           # Smaller batches if API is rate-limited\n    max_retries=5,           # More retries if API is unstable\n    retry_delay=2.0,         # Longer initial backoff (1s → 2s → 4s → ...)\n    rate_limit_delay=1.0,    # Longer delay between requests\n)\n```\n\n## How It Works\n\n### Batch Strategy\n\n1. **First phase**: Request origin (point 0) + batches of waypoints\n   ```\n   Request 1: distances from 0 to [1, 2, ..., 95]\n   Request 2: distances from 0 to [96, 97, ..., 150]\n   ```\n\n2. **Second phase**: Request each waypoint as origin to remaining waypoints\n   ```\n   Request 3: distances from 1 to [2, 3, ..., 95]\n   Request 4: distances from 1 to [96, 97, ..., 150]\n   Request 5: distances from 2 to [3, 4, ..., 95]\n   ...\n   ```\n\n### Error Handling\n\nAutomatically:\n- **Retries** failed requests with exponential backoff (1s → 2s → 4s)\n- **Tracks** failed pairs and falls back to geodesic distance\n- **Respects** API rate limits with configurable delays\n- **Validates** responses and handles malformed data\n\n## Integration with webRotas\n\nAutomatically used in `controller()` when:\n\n1. Direct public API fails\n2. Local container is unavailable\n3. Coordinates exceed API limits\n\n```python\n# In api_routing.py - automatic fallback chain:\n# Try public API → Try local container → Try iterative builder → Fallback to geodesic\n```\n\n## Performance Guidelines\n\n| Coordinates | Batches | Estimated Time | Notes |\n|-------------|---------|----------------|-------|\n| 50 | 2 | <5 seconds | Fast, use for testing |\n| 100 | 5 | ~10 seconds | Typical quick job |\n| 200 | ~25 | ~1-2 minutes | Common use case |\n| 500 | ~130 | ~5-8 minutes | Large grid |\n| 1000 | ~500 | ~15-25 minutes | Very large job |\n\n*Times assume 1s API latency per batch + 0.5s rate limit delay*\n\n## Configuration Tuning\n\n### If Getting Rate Limited\n```python\nbuilder = IterativeMatrixBuilder(\n    coords,\n    batch_size=50,           # Smaller batches\n    rate_limit_delay=2.0,    # Longer between requests\n)\n```\n\n### If API is Unstable\n```python\nbuilder = IterativeMatrixBuilder(\n    coords,\n    max_retries=5,           # More attempts\n    retry_delay=2.0,         # Longer backoff\n)\n```\n\n### If You're in a Hurry\n```python\nbuilder = IterativeMatrixBuilder(\n    coords,\n    batch_size=95,           # Keep at max\n    max_retries=1,           # Fail fast\n    rate_limit_delay=0.2,    # Aggressive rate limit\n)\n```\n\n## Output Matrices\n\n### Structure\n\n```python\n# Both are NxN matrices (N = number of coordinates)\ndistances  # [meters] between all coordinate pairs\ndurations  # [seconds] between all coordinate pairs\n\n# Properties:\n# - distances[i][i] == 0 (same point = 0 distance)\n# - distances[i][j] >= 0 (never negative)\n# - distances[i][j] ≈ distances[j][i] (approximately symmetric)\n```\n\n### Example\n\n```python\ncoords = [{\"lat\": -23.55, \"lng\": -46.57}, ...]\nbuilder = IterativeMatrixBuilder(coords)\ndistances, durations = builder.build()\n\n# 100 coordinates = 100x100 matrix\nassert len(distances) == 100\nassert len(distances[0]) == 100\n\n# Distance from point i to point j\ndist_ij = distances[i][j]  # meters\ntime_ij = durations[i][j]   # seconds\n\n# Speed calculation\nspeed_kmh = (dist_ij / 1000) / (time_ij / 3600)\n```\n\n## Troubleshooting\n\n### \"Matrix build completed but has many geodesic values\"\n→ API is unreliable, try:\n- Longer `rate_limit_delay` to avoid overwhelming it\n- Smaller `batch_size` to reduce request size\n- Later time when API less congested\n\n### \"Takes too long\"\n→ Speed up with (at your risk):\n- Increase `batch_size` to 95 (already max)\n- Decrease `rate_limit_delay` \n- Decrease `max_retries`\n- Use fewer coordinates (filter/aggregate first)\n\n### \"Getting timeout errors\"\n→ Use:\n- Longer `retry_delay` and more `max_retries`\n- Smaller `batch_size` to make requests smaller\n- Longer `rate_limit_delay` to avoid congestion\n\n## Logging Output\n\nEnable debug logging to see details:\n\n```python\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Then build\nbuilder = IterativeMatrixBuilder(coords)\ndistances, durations = builder.build()\n```\n\nExpected output:\n```\nINFO: Starting iterative matrix build for 250 coordinates with batch size 95\nINFO: Created 421 batches for API requests\nDEBUG: Processing batch 1/421 (origin 0, waypoints 95)\nDEBUG: Processing batch 2/421 (origin 0, waypoints 95)\n...\nINFO: Applying geodesic fallback for 12 failed pairs\nINFO: Matrix build completed successfully\n```\n\n## API Rate Limits\n\nPublic OSRM has standard rate limits:\n- ~600 requests per hour\n- ~10 requests per second (burst)\n- Shared across all users\n\n**Default settings are conservative** to work well for shared API.\n\n## When to Use vs Local Container\n\n| Scenario | Use Iterative | Use Container |\n|----------|---------------|---------------|\n| <100 coordinates | Direct API | Either |\n| >100 coordinates | Iterative | Preferred |\n| Container down | **Iterative** | N/A |\n| API down | Container | Fallback to geodesic |\n| Both down | Use iterative (slower) | ✓ Iterative |\n| Avoid zones needed | Container | Not supported |\n| Must be fast | Container | Better |\n| Want to avoid overhead | Iterative | Use API directly |\n"