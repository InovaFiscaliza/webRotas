# Iterative Matrix Builder - Complete Guide\n\n## ğŸ“‹ Documentation Index\n\n### Quick Start\n- **[ITERATIVE_QUICK_REF.md](./ITERATIVE_QUICK_REF.md)** - Start here!\n  - 5-minute overview\n  - Basic usage examples\n  - Common troubleshooting\n  - Performance expectations\n\n### Implementation Details\n- **[IMPLEMENTATION_SUMMARY.md](./IMPLEMENTATION_SUMMARY.md)** - What was built\n  - Files created and modified\n  - Code changes overview\n  - Algorithm high-level description\n  - Feature checklist\n\n### Architecture & Design\n- **[ARCHITECTURE.md](./ARCHITECTURE.md)** - How it works\n  - System integration flow\n  - Batch processing pipeline\n  - Error handling strategy\n  - Performance analysis\n  - Class diagrams\n\n### Deep Dive\n- **[iterative_matrix_builder.md](./iterative_matrix_builder.md)** - Technical details\n  - Algorithm explanation with examples\n  - Configuration parameter tuning\n  - Performance characteristics\n  - Future enhancement ideas\n\n## ğŸš€ Quick Start (2 minutes)\n\n```python\nfrom webrotas.iterative_matrix_builder import IterativeMatrixBuilder\n\n# Create builder with your coordinates\ncoords = [{\"lat\": -23.55, \"lng\": -46.57}, ...]  # 100+ points\nbuilder = IterativeMatrixBuilder(coords)\n\n# Build matrix\ndistances, durations = builder.build()\n\n# Use for routing\nprint(f\"Distance 0â†’1: {distances[0][1]} meters\")\n```\n\n## ğŸ”§ When to Use\n\nâœ… **Use Iterative Builder When:**\n- Local container is unavailable/crashed\n- You have >100 coordinates\n- You want public API fallback\n- Network is available to public OSRM\n\nâŒ **Don't Use When:**\n- Local container is working (faster)\n- <100 coordinates (use direct API)\n- Offline/no external API access\n\n## ğŸ“Š Performance Guide\n\n| Coordinates | Time | Notes |\n|-------------|------|-------|\n| 50 | <5s | Very fast |\n| 100 | ~10s | Typical |\n| 200 | 1-2m | Common |\n| 500 | 5-8m | Large |\n| 1000+ | 15-25m | Very large |\n\n## âš™ï¸ Configuration Tuning\n\n### Default (Conservative)\n```python\nbuilder = IterativeMatrixBuilder(coords)\n# batch_size=95, max_retries=3, retry_delay=1.0s, rate_limit_delay=0.5s\n```\n\n### If API is Rate-Limited\n```python\nbuilder = IterativeMatrixBuilder(\n    coords,\n    batch_size=50,\n    rate_limit_delay=2.0\n)\n```\n\n### If You Need Speed (Risky)\n```python\nbuilder = IterativeMatrixBuilder(\n    coords,\n    batch_size=95,\n    max_retries=1,\n    rate_limit_delay=0.1\n)\n```\n\n## ğŸ” How It Works (30 seconds)\n\n1. **Splits** coordinates into batches (95 waypoints max)\n2. **Requests** batches from public OSRM API sequentially\n3. **Retries** failures with exponential backoff\n4. **Rate limits** between requests (0.5s default)\n5. **Merges** responses into complete NxN matrix\n6. **Falls back** to geodesic for any failed pairs\n\n## ğŸ“ File Structure\n\n```\nwebRotas/\nâ”œâ”€â”€ src/webrotas/\nâ”‚   â””â”€â”€ iterative_matrix_builder.py     [Core implementation - 11 KB]\nâ”‚\nâ”œâ”€â”€ tests/\nâ”‚   â””â”€â”€ test_iterative_matrix_builder.py [Comprehensive tests - 14 KB]\nâ”‚\nâ””â”€â”€ docs/summaries/\n    â”œâ”€â”€ README_ITERATIVE.md             [This file]\n    â”œâ”€â”€ ITERATIVE_QUICK_REF.md          [Quick reference]\n    â”œâ”€â”€ ARCHITECTURE.md                 [System design]\n    â”œâ”€â”€ IMPLEMENTATION_SUMMARY.md       [What was built]\n    â””â”€â”€ iterative_matrix_builder.md     [Technical details]\n```\n\n## ğŸ”— Integration Points\n\n### Automatic (No Code Changes Needed)\nUsed automatically in `api_routing.controller()` fallback chain:\n```\nDirect API â†’ Local Container â†’ Iterative Builder â†’ Geodesic\n```\n\n### Manual Usage\n```python\nfrom webrotas.iterative_matrix_builder import IterativeMatrixBuilder\n\nbuilder = IterativeMatrixBuilder(coords)\ndistances, durations = builder.build()\n```\n\n## ğŸ› Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| \"Too many geodesic values\" | Longer `rate_limit_delay`, API may be unreliable |\n| \"Takes too long\" | Reduce `rate_limit_delay`, increase `batch_size` |\n| \"Timeout errors\" | Longer `retry_delay`, more `max_retries` |\n| \"Still fails\" | Check internet, try later, increase delays |\n\nSee [ITERATIVE_QUICK_REF.md](./ITERATIVE_QUICK_REF.md#troubleshooting) for more.\n\n## ğŸ“ˆ Performance Expectations\n\n- **Small sets** (50 coords): Few seconds, 1-2 API batches\n- **Medium sets** (200 coords): 1-2 minutes, ~25 API batches\n- **Large sets** (500+ coords): Several minutes/hours, proportional to NÂ²\n\nâš ï¸ **Note**: Time is dominated by API latency, not algorithm.\n\n## ğŸ”„ Fallback Behavior\n\n```\nScenario: Container down, 200 coordinates\n\n1. Direct API fails (too many coords)\n2. Container not available\n3. Iterative builder activated\n   â”œâ”€ Splits into ~25 batches\n   â”œâ”€ Makes sequential API requests\n   â”œâ”€ Most succeed, few might fail\n   â””â”€ Failed pairs use geodesic fallback\n4. Returns complete matrix\n   â””â”€ Good for routing optimization\n```\n\n## âœ… Testing\n\nComprehensive tests in `tests/test_iterative_matrix_builder.py`:\n\n```bash\nuv run python -m pytest tests/test_iterative_matrix_builder.py -v\n```\n\nCovers:\n- Batch creation logic\n- Response merging\n- Retry and backoff\n- Rate limiting\n- Error handling\n- Matrix properties\n- Edge cases\n\n## ğŸ“š Key Concepts\n\n### RequestBatch\nRepresents one API request batch:\n- Max 95 waypoints per batch (respects 100 API limit)\n- Contains origin index + waypoint indices\n- Formats coordinates as OSRM URL parameter\n\n### IterativeMatrixBuilder\nMain class orchestrating the process:\n- Creates batches respecting API constraints\n- Manages requests with retry logic\n- Merges responses into complete matrix\n- Handles fallback to geodesic\n\n### Rate Limiting\nRespects public OSRM API limits:\n- Default 0.5s between requests\n- ~2 requests/second = safe for public API\n- Configurable if needed\n\n## ğŸ› ï¸ Advanced Usage\n\n### Custom Configuration\n```python\nbuilder = IterativeMatrixBuilder(\n    coords,\n    batch_size=80,           # Smaller batches\n    max_retries=5,           # More retries\n    retry_delay=2.0,         # Longer backoff\n    rate_limit_delay=1.0,    # Longer between requests\n)\n```\n\n### Enable Debug Logging\n```python\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\nbuilder.build()  # Shows detailed progress\n```\n\n### Batch Statistics\n```python\nbuilder = IterativeMatrixBuilder(coords)\nbatches = builder._create_batches()\nprint(f\"Batches needed: {len(batches)}\")\nprint(f\"Total API requests: ~{len(batches)}\")\nprint(f\"Estimated time: {len(batches) * 0.5 + len(batches) * 1}s\")\n```\n\n## ğŸ¯ Design Principles\n\n1. **Reliability**: Works even when container/API has issues\n2. **Rate-aware**: Conservative defaults safe for public API\n3. **Graceful degradation**: Always produces valid matrices\n4. **Observable**: Comprehensive logging for debugging\n5. **Tunable**: All parameters configurable for different needs\n6. **Maintainable**: Clear structure, well-documented code\n\n## ğŸ“ Support\n\nFor issues or questions:\n1. Check [ITERATIVE_QUICK_REF.md](./ITERATIVE_QUICK_REF.md) troubleshooting\n2. Review [ARCHITECTURE.md](./ARCHITECTURE.md) for detailed flow\n3. Check logs (enable DEBUG level)\n4. Adjust configuration parameters\n\n## ğŸ“ Summary\n\n**What**: Builds distance/duration matrices using public OSRM API in batches\n**When**: Container unavailable, large coordinate sets, need fallback\n**How**: Splits into batches, sequential requests, retry logic, geodesic fallback\n**Performance**: O(NÂ²) where N = coordinates, scales with API latency\n**Result**: Valid matrices suitable for route optimization\n\n---\n\n**Next**: Read [ITERATIVE_QUICK_REF.md](./ITERATIVE_QUICK_REF.md) for quick start!\n"